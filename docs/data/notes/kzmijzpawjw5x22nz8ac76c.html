<h1 id="s2-geometry">S2 Geometry<a aria-hidden="true" class="anchor-heading icon-link" href="#s2-geometry"></a></h1>
<ul>
<li>url: <a href="https://s2geometry.io">https://s2geometry.io</a></li>
<li><a class="color-tag" style="--tag-color: #f8481c;" href="/wiki/notes/kd2y68m8dvq5lo54t4kytss">#topic</a> <a href="/wiki/notes/0qnncv8chs2a9lp1tjtqzg2">Geometry</a> </li>
</ul>
<h2 id="resources">Resources<a aria-hidden="true" class="anchor-heading icon-link" href="#resources"></a></h2>
<ul>
<li><a href="https://s2geometry.io/resources/earthcube">https://s2geometry.io/resources/earthcube</a></li>
</ul>
<h2 id="highlights">Highlights<a aria-hidden="true" class="anchor-heading icon-link" href="#highlights"></a></h2>
<ul>
<li>In S2, points are represented internally as unit-length vectors (points on the surface of a three-dimensional unit sphere) as opposed to traditional (latitude, longitude) pairs. This is for two reasons:</li>
</ul>
<p>Unit vectors are much more efficient when working with geodesic edges. Using (latitude, longitude) pairs would require constantly evaluating trigonometric functions (sin, cos, etc), which is slow even on modern CPU architectures.</p>
<p>Unit vectors allow exact geometric predicates to be evaluated efficiently. To do this with (latitude, longitude) pairs, you would essentially need to convert them to the unit vector representation first.</p>