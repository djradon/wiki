<h1 id="brackit">Brackit<a aria-hidden="true" class="anchor-heading icon-link" href="#brackit"></a></h1>
<ul>
<li>repo: <a href="https://github.com/sirixdb/brackit">https://github.com/sirixdb/brackit</a></li>
</ul>
<h2 id="mission">Mission<a aria-hidden="true" class="anchor-heading icon-link" href="#mission"></a></h2>
<p>Our work is guided by the following basic questions:</p>
<ul>
<li>What is an appropriate level of abstraction for accessing and (de-)composing semi-structured data? How should we represent semi-structured data with deep nestings and varying sizes at runtime? How can we support native operations and alternative access methods, i.e., indexes etc.?</li>
<li>How should we represent queries, whole scripts, and user-defined functions to leverage proven optimization techniques from both query languages (e.g., predicate-pushdown, join ordering, optimized aggregation) and programming languages (e.g., tail recursion)?</li>
<li>How can we support different evaluation philosophies (pull-based, push-based, mixed push/pull) and proven query algorithms?. How can we (automatically) exploit partitioned data, parallel hardware and query-inherent parallelism?</li>
<li>How can we incorporate physical and system-specific properties (e.g., memory locality) in the compilation and evaluation process?</li>
</ul>
<h2 id="references">References<a aria-hidden="true" class="anchor-heading icon-link" href="#references"></a></h2>
<ul>
<li><a href="https://github.com/sirixdb/brackit/blob/master/mission.md">https://github.com/sirixdb/brackit/blob/master/mission.md</a></li>
</ul>
<hr>
<strong>Backlinks</strong>
<ul>
<li><a href="/wiki/notes/i388nbhc8kgy4chr0t1637t">SirixDB (public-notes)</a></li>
</ul>