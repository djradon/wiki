<h1 id="exploring-advanced-error-handling-patterns-with-event-driven-architecture-part-i">Exploring Advanced Error Handling Patterns with Event Driven Architecture Part I<a aria-hidden="true" class="anchor-heading icon-link" href="#exploring-advanced-error-handling-patterns-with-event-driven-architecture-part-i"></a></h1>
<ul>
<li><a href="https://medium.com/ssense-tech/exploring-advanced-error-handling-patterns-with-event-driven-architecture-part-i-e2f37741d904">https://medium.com/ssense-tech/exploring-advanced-error-handling-patterns-with-event-driven-architecture-part-i-e2f37741d904</a></li>
</ul>
<h2 id="conclusion">Conclusion<a aria-hidden="true" class="anchor-heading icon-link" href="#conclusion"></a></h2>
<p>event-driven architectures come with the need for more complex error detection and handling.</p>
<p>Assessing whether the trade-off actually pays off is an exercise that you have to do and ultimately your context will dictate if it is the right choice.</p>
<p>If that is the case for you, then revisit where it is applied and look for signs that you should be adopting a choreographed saga to make those errors visible. Then, determine which errors are transient or permanent to tailor your application and achieve a self-healing status as much as possible.</p>
<p>Finally, be aware that dead letter queues, while helpful, have to be treated as first-class citizens of your application. This means ensuring you actively monitor the DLQs and look for ways to improve your application as each root cause of the message is identified.</p>
<hr>
<strong>Backlinks</strong>
<ul>
<li><a href="/wiki/notes/ehflhupgftjncjisnmcxyzy">Event Driven Architecture (public-notes)</a></li>
</ul>