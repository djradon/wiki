<h1 id="building-games-in-ecs-with-entity-relationships">Building Games in Ecs with Entity Relationships<a aria-hidden="true" class="anchor-heading icon-link" href="#building-games-in-ecs-with-entity-relationships"></a></h1>
<ul>
<li>
<p>url: <a href="https://ajmmertens.medium.com/building-games-in-ecs-with-entity-relationships-657275ba2c6c">https://ajmmertens.medium.com/building-games-in-ecs-with-entity-relationships-657275ba2c6c</a></p>
</li>
<li>
<p><a href="/wiki/notes/Oo8aTwi9pleJGCwe0hvG7">Topic</a> <a href="/wiki/notes/7gdppz90ynqtxqlw29ln9jj">Flecs</a></p>
</li>
<li>
<p>inspiration: prolog</p>
</li>
<li>
<p>"player_2 is a regular entity, which means we canâ€™t know its identifier before running the game. This is different from a regular component, which (in most ECS frameworks) has to be known at compile time. This brings us to the second defining feature of relationships: Relationship pairs can contain regular entities"</p>
</li>
<li>
<p>"Queries are treated as a list of nodes. Each node implements a function that can return either true or false. When a node returns true, the query moves on to the next node. When a node returns false, it goes back one node. These kinds of functions are called predicates, and this evaluation process is called backtracking."</p>
<ul>
<li>"ECS queries on the other hand already use fast data structures for finding entities, and with the few tweaks we discussed here they can be extended to general-purpose query engines for graphs."</li>
</ul>
</li>
</ul>
<h2 id="references">References<a aria-hidden="true" class="anchor-heading icon-link" href="#references"></a></h2>
<ul>
<li><a href="https://ajmmertens.medium.com/yep-it-is-i-took-a-lot-of-inspiration-from-prolog-while-i-was-designing-the-query-language-b27667f49e03">https://ajmmertens.medium.com/yep-it-is-i-took-a-lot-of-inspiration-from-prolog-while-i-was-designing-the-query-language-b27667f49e03</a></li>
</ul>