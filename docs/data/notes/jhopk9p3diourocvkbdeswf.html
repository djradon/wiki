<h1 id="full-stack-linked-data">Full Stack Linked Data<a aria-hidden="true" class="anchor-heading icon-link" href="#full-stack-linked-data"></a></h1>
<ul>
<li><a href="https://ontola.io/blog/full-stack-linked-data">https://ontola.io/blog/full-stack-linked-data</a></li>
<li>related: <a href="/wiki/notes/d63bo2zkaf2ufr7zbcy9xsj">Ndjson</a></li>
</ul>
<h2 id="highlights">Highlights<a aria-hidden="true" class="anchor-heading icon-link" href="#highlights"></a></h2>
<ul>
<li>CTO <a href="/wiki/notes/8aex8n34hy6ailudklrw8pw">@thom-van-kalkeren</a> thoroughly studied the principles behind REST, HATEOS and Hypermedia, and concluded that we need to give everything URLs. Not just the pages that we present to our users, but every single thing that can be used by a client - including menu items, buttons, actions and form fields.</li>
<li><a href="/wiki/notes/w7q1wkr03xp8nsxjubx687o">Linked Delta</a></li>
<li><a aria-hidden="true" class="block-anchor anchor-heading icon-link" id="^mzabxzsavtsd" href="#^mzabxzsavtsd"></a>the RDF representation of data can be created during serialization - so your app can create linked data without using a triple store! </li>
</ul>
<h3 id="why-linked-data">Why Linked Data?<a aria-hidden="true" class="anchor-heading icon-link" href="#why-linked-data"></a></h3>
<ul>
<li><strong>Browsable</strong>. Using links for everything in data, means that data can be surfed like how web pages work: just follow the URLs. That's actually really helpful in a web application, since this means that the client no longer needs to be aware of your routing logic.</li>
<li><strong>Flexibility</strong>. Everything can be serialized to various formats (JSON, XML, Turtle, N-Triples, and <a href="https://ontola.io/blog/rdf-serialization-formats/">more</a>), which gives some really nice and flexible export functionality.</li>
<li><strong>Self-describing APIs</strong>. Simply use content-type negotiation to fetch a resource as HTML or some RDF format, and browse the data like you would browse a website: by following the links. API docs become kind of unnecessary, since navigating the website shows you all the endpoints.</li>
<li><strong>Re-use other linked data</strong>. Because links can point to <em>anywhere</em> (not just your server), you can use all the publicly available linked data! This, for me, has always been the number one reason to believe in Linked Data.</li>
<li><strong>Enables true data ownership</strong>. Because of this, it enables <em>decentralized networks</em> where people <em>own their data</em>, which can help to combat the existing web oligopoly. That's what the <a href="https://ontola.io/solid">Solid project</a> is all about.</li>
<li></li>
</ul>
<h3 id="why-not-use-sparql">Why not use SPARQL?<a aria-hidden="true" class="anchor-heading icon-link" href="#why-not-use-sparql"></a></h3>
<ul>
<li><a href="/wiki/notes/ln6efm5dgf1lqtozblp35bk">Sparql</a> is the de facto query language for RDF data, so it seems logical to use it somewhere in our stack. However, we don't. 
<ul>
<li>Getting SPARQL performant is actually pretty difficult, and we don't need the powerful query options that it provides. </li>
<li>Most of the requests from the front-end just ask for all triples about one or multiple subjects, and these kind of queries don't require SPARQL. </li>
<li>SPARQL is useful for more complex graph property traversal queries, but is not necessarily the best approach for simpler queries.</li>
</ul>
</li>
</ul>
<hr>
<strong>Backlinks</strong>
<ul>
<li><a href="/wiki/notes/ixo57369vpbk2dk99bv2s1e">Ontola</a></li>
</ul>