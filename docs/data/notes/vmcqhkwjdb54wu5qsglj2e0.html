<h1 id="lume-land-fork">Lume Land Fork<a aria-hidden="true" class="anchor-heading icon-link" href="#lume-land-fork"></a></h1>
<h2 id="forking-lumeland-dave">forking lume.land (dave)<a aria-hidden="true" class="anchor-heading icon-link" href="#forking-lumeland-dave"></a></h2>
<p>I'd like to fork <a href="https://github.com/lumeland/lume.land">https://github.com/lumeland/lume.land</a> and gut all the content to use it as a template for future websites. If I fork it, can I merge in upstream updates only for files that I haven't deleted?</p>
<h2 id="forking-lumeland-chatgpt">forking lume.land (chatgpt)<a aria-hidden="true" class="anchor-heading icon-link" href="#forking-lumeland-chatgpt"></a></h2>
<p>Yes, you can fork the Lume.land repository and modify it as needed while retaining the ability to merge upstream updates selectively. Here's how you can approach this:</p>
<h3 id="1-fork-the-repository">1. <strong>Fork the Repository</strong><a aria-hidden="true" class="anchor-heading icon-link" href="#1-fork-the-repository"></a></h3>
<ul>
<li>Use GitHub's "Fork" button to create your fork of the <code>lume.land</code> repository.</li>
</ul>
<h3 id="2-create-a-working-branch">2. <strong>Create a Working Branch</strong><a aria-hidden="true" class="anchor-heading icon-link" href="#2-create-a-working-branch"></a></h3>
<ul>
<li>Create a branch in your fork where you'll modify or delete content:
<pre class="language-bash"><code class="language-bash"><span class="token function">git</span> checkout -b template-base
</code></pre>
</li>
</ul>
<h3 id="3-remove-unwanted-files">3. <strong>Remove Unwanted Files</strong><a aria-hidden="true" class="anchor-heading icon-link" href="#3-remove-unwanted-files"></a></h3>
<ul>
<li>Delete or modify the content you don't need.</li>
</ul>
<h3 id="4-commit-your-changes">4. <strong>Commit Your Changes</strong><a aria-hidden="true" class="anchor-heading icon-link" href="#4-commit-your-changes"></a></h3>
<ul>
<li>Commit the changes in your working branch:
<pre class="language-bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span>
<span class="token function">git</span> commit -m <span class="token string">"Gutted lume.land content for template use"</span>
</code></pre>
</li>
</ul>
<h3 id="5-track-the-original-repository">5. <strong>Track the Original Repository</strong><a aria-hidden="true" class="anchor-heading icon-link" href="#5-track-the-original-repository"></a></h3>
<ul>
<li>Add the original repository as a remote to pull upstream changes:
<pre class="language-bash"><code class="language-bash"><span class="token function">git</span> remote <span class="token function">add</span> upstream https://github.com/lumeland/lume.land.git
</code></pre>
</li>
</ul>
<h3 id="6-fetch-and-merge-updates">6. <strong>Fetch and Merge Updates</strong><a aria-hidden="true" class="anchor-heading icon-link" href="#6-fetch-and-merge-updates"></a></h3>
<ul>
<li>
<p>To fetch the latest changes from the upstream repository:</p>
<pre class="language-bash"><code class="language-bash"><span class="token function">git</span> fetch upstream
</code></pre>
</li>
<li>
<p>Merge upstream updates into your branch:</p>
<pre class="language-bash"><code class="language-bash"><span class="token function">git</span> merge upstream/main
</code></pre>
</li>
<li>
<p>During the merge, Git will automatically skip files you've deleted, as they don't exist in your branch. If a file you've modified conflicts with upstream changes, Git will prompt you to resolve those conflicts manually.</p>
</li>
</ul>
<h3 id="7-selective-updates">7. <strong>Selective Updates</strong><a aria-hidden="true" class="anchor-heading icon-link" href="#7-selective-updates"></a></h3>
<ul>
<li>If you only want to update certain files from upstream, you can cherry-pick commits or selectively merge specific paths:
<pre class="language-bash"><code class="language-bash"><span class="token function">git</span> fetch upstream
<span class="token function">git</span> checkout upstream/main -- path/to/file
<span class="token function">git</span> commit -m <span class="token string">"Merged upstream changes for path/to/file"</span>
</code></pre>
</li>
</ul>
<h3 id="8-keep-a-clean-workflow">8. <strong>Keep a Clean Workflow</strong><a aria-hidden="true" class="anchor-heading icon-link" href="#8-keep-a-clean-workflow"></a></h3>
<ul>
<li>Use a branch (like <code>template-base</code>) for maintaining your template, and merge from upstream into this branch periodically.</li>
<li>For new websites, create separate branches or repositories based on the <code>template-base</code> branch.</li>
</ul>
<p>By following this workflow, you can maintain your custom template while still incorporating upstream changes selectively, avoiding unwanted modifications to your customizations.</p>
<h2 id="why-not-just-use-main">why not just use main?<a aria-hidden="true" class="anchor-heading icon-link" href="#why-not-just-use-main"></a></h2>
<p>Using <code>main</code> directly for your modifications is possible, but there are important reasons why maintaining a separate branch for your customizations (like <code>template-base</code>) can be beneficial:</p>
<hr>
<h3 id="1-protecting-your-customizations"><strong>1. Protecting Your Customizations</strong><a aria-hidden="true" class="anchor-heading icon-link" href="#1-protecting-your-customizations"></a></h3>
<ul>
<li><strong>Separate Workspace:</strong> By keeping <code>main</code> clean and using a branch like <code>template-base</code> for your modifications, you can pull upstream changes into <code>main</code> without risking overwriting or conflicting with your custom changes.</li>
<li>If you use <code>main</code> directly, merging updates from <code>upstream/main</code> can become riskier because it may overwrite your changes or create complex conflicts.</li>
</ul>
<hr>
<h3 id="2-easier-upstream-merges"><strong>2. Easier Upstream Merges</strong><a aria-hidden="true" class="anchor-heading icon-link" href="#2-easier-upstream-merges"></a></h3>
<ul>
<li><strong>Keep <code>main</code> Aligned:</strong> If <code>main</code> is reserved for an unmodified version of the upstream repository, it becomes much easier to fetch and merge upstream changes without worrying about resolving conflicts caused by your customizations.</li>
<li><strong>Selective Updates:</strong> By maintaining <code>template-base</code> for customizations, you can cherry-pick changes from <code>main</code> to your branch, allowing granular control over which updates are integrated.</li>
</ul>
<hr>
<h3 id="3-reusability-for-multiple-projects"><strong>3. Reusability for Multiple Projects</strong><a aria-hidden="true" class="anchor-heading icon-link" href="#3-reusability-for-multiple-projects"></a></h3>
<ul>
<li><strong>Base Template for New Projects:</strong> A dedicated branch like <code>template-base</code> can serve as the starting point for new projects, while <code>main</code> remains a reference to the original upstream repository.</li>
<li>This setup ensures that all your projects consistently inherit your modifications without carrying unnecessary upstream history.</li>
</ul>
<hr>
<h3 id="4-reducing-merge-complexity"><strong>4. Reducing Merge Complexity</strong><a aria-hidden="true" class="anchor-heading icon-link" href="#4-reducing-merge-complexity"></a></h3>
<ul>
<li>If your customizations live in <code>main</code>, merging upstream changes directly into <code>main</code> can result in conflicts for every file you’ve deleted or modified.</li>
<li>With a separate branch, you merge upstream updates into <code>main</code> first, then handle integrating updates into <code>template-base</code> more selectively, focusing only on files that matter to you.</li>
</ul>
<hr>
<h3 id="5-safe-rollbacks"><strong>5. Safe Rollbacks</strong><a aria-hidden="true" class="anchor-heading icon-link" href="#5-safe-rollbacks"></a></h3>
<ul>
<li>If an upstream change breaks something in your workflow, having <code>main</code> as a pristine copy of upstream makes it easy to compare, debug, or roll back changes without impacting your customized branch.</li>
</ul>
<hr>
<h3 id="recommended-workflow">Recommended Workflow:<a aria-hidden="true" class="anchor-heading icon-link" href="#recommended-workflow"></a></h3>
<ol>
<li>
<p><strong>Use <code>main</code> for Upstream Tracking:</strong></p>
<ul>
<li>Keep <code>main</code> aligned with the upstream repository:
<pre class="language-bash"><code class="language-bash"><span class="token function">git</span> fetch upstream
<span class="token function">git</span> merge upstream/main
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Customize in a Separate Branch:</strong></p>
<ul>
<li>Create and maintain <code>template-base</code> for your customizations:
<pre class="language-bash"><code class="language-bash"><span class="token function">git</span> checkout -b template-base
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Selective Updates:</strong></p>
<ul>
<li>When upstream changes occur, merge them into <code>main</code> first.</li>
<li>From <code>main</code>, cherry-pick or merge specific updates into <code>template-base</code>:
<pre class="language-bash"><code class="language-bash"><span class="token function">git</span> checkout template-base
<span class="token function">git</span> merge main
</code></pre>
</li>
</ul>
</li>
</ol>
<hr>
<p>This workflow ensures you retain full control over your customizations while staying up-to-date with upstream changes in a structured, conflict-minimized way.</p>
<h2 id="should-i-preserve-the-repo-name-lumeland-for-my-fork">should I preserve the repo name (lume.land) for my fork?<a aria-hidden="true" class="anchor-heading icon-link" href="#should-i-preserve-the-repo-name-lumeland-for-my-fork"></a></h2>
<p>It’s generally better to <strong>rename your fork</strong> instead of preserving the original name (<code>lume.land</code>) in most cases, especially if your fork is going to be used as a template for future projects. Here’s a breakdown of why:</p>
<hr>
<h3 id="reasons-to-rename-your-fork"><strong>Reasons to Rename Your Fork</strong><a aria-hidden="true" class="anchor-heading icon-link" href="#reasons-to-rename-your-fork"></a></h3>
<h4 id="1-avoid-confusion">1. <strong>Avoid Confusion</strong><a aria-hidden="true" class="anchor-heading icon-link" href="#1-avoid-confusion"></a></h4>
<ul>
<li>If your fork has the same name as the original repository, it can cause confusion for contributors, collaborators, or even for yourself in the long run. Renaming it makes it clear that your repository serves a different purpose (e.g., a stripped-down template).</li>
</ul>
<h4 id="2-clarify-its-purpose">2. <strong>Clarify its Purpose</strong><a aria-hidden="true" class="anchor-heading icon-link" href="#2-clarify-its-purpose"></a></h4>
<ul>
<li>A new name can reflect the purpose of your fork, such as:
<ul>
<li><code>lume-template</code></li>
<li><code>website-template</code></li>
<li><code>base-site</code></li>
</ul>
</li>
<li>This makes it easier for others to understand that this is a custom version meant for template use rather than an exact copy of the upstream.</li>
</ul>
<h4 id="3-differentiate-in-local-development">3. <strong>Differentiate in Local Development</strong><a aria-hidden="true" class="anchor-heading icon-link" href="#3-differentiate-in-local-development"></a></h4>
<ul>
<li>When cloning multiple repositories, it’s easier to identify which is your customized fork if it has a unique name. Keeping <code>lume.land</code> may lead to accidental confusion with the upstream repository.</li>
</ul>
<h4 id="4-show-ownership">4. <strong>Show Ownership</strong><a aria-hidden="true" class="anchor-heading icon-link" href="#4-show-ownership"></a></h4>
<ul>
<li>By renaming, you emphasize that the fork is tailored to your needs and not an official or endorsed version of <code>lume.land</code>.</li>
</ul>
<hr>
<h3 id="when-to-keep-the-original-name"><strong>When to Keep the Original Name</strong><a aria-hidden="true" class="anchor-heading icon-link" href="#when-to-keep-the-original-name"></a></h3>
<h4 id="1-direct-customization-with-clear-attribution">1. <strong>Direct Customization with Clear Attribution</strong><a aria-hidden="true" class="anchor-heading icon-link" href="#1-direct-customization-with-clear-attribution"></a></h4>
<ul>
<li>If your fork will closely mirror the original <code>lume.land</code> and you want to signal that your repository is a derivative, keeping the original name makes sense. This is more applicable if you don’t intend to change the content significantly.</li>
</ul>
<h4 id="2-minimal-modifications">2. <strong>Minimal Modifications</strong><a aria-hidden="true" class="anchor-heading icon-link" href="#2-minimal-modifications"></a></h4>
<ul>
<li>If your changes are light and you plan to maintain close synchronization with the upstream repository, keeping the name <code>lume.land</code> might reduce friction when merging updates.</li>
</ul>
<hr>
<h3 id="recommendations"><strong>Recommendations</strong><a aria-hidden="true" class="anchor-heading icon-link" href="#recommendations"></a></h3>
<ol>
<li>
<p><strong>If You’re Using It as a Template:</strong></p>
<ul>
<li>Rename it to reflect its purpose, such as:
<pre class="language-text"><code class="language-text">lume-template
base-website
stripped-lume
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>If You’re Extending It Closely:</strong></p>
<ul>
<li>Keep the name <code>lume.land</code> if you want to indicate a strong connection to the upstream project.</li>
</ul>
</li>
</ol>
<hr>
<h3 id="how-to-rename-your-fork">How to Rename Your Fork<a aria-hidden="true" class="anchor-heading icon-link" href="#how-to-rename-your-fork"></a></h3>
<ol>
<li>Go to your fork’s GitHub repository page.</li>
<li>Click <strong>Settings</strong>.</li>
<li>In the <strong>Repository Name</strong> field, change it to your preferred name.</li>
<li>Click <strong>Rename</strong>.</li>
</ol>
<p>GitHub will automatically redirect the old URL to the new one, so links to the original forked repo will still work.</p>
<p>By renaming, you make your repository’s purpose more apparent and maintain clarity for yourself and others who might work with it.</p>
<h2 id="should-i-make-it-a-template-repository-how-about-making-the-default-branch-the-new-template-clean-branch-instead-of-main">should I make it a "template repository"? How about making the default branch the new "template-clean" branch instead of main?<a aria-hidden="true" class="anchor-heading icon-link" href="#should-i-make-it-a-template-repository-how-about-making-the-default-branch-the-new-template-clean-branch-instead-of-main"></a></h2>
<p>Both approaches—making it a <strong>template repository</strong> and setting the default branch to <code>template-clean</code>—can work well for your use case, but they serve different purposes. Here's how to decide:</p>
<hr>
<h3 id="making-it-a-template-repository"><strong>Making It a Template Repository</strong><a aria-hidden="true" class="anchor-heading icon-link" href="#making-it-a-template-repository"></a></h3>
<p>A <strong>template repository</strong> is ideal if:</p>
<ul>
<li>You plan to use it as the basis for creating new repositories frequently.</li>
<li>You want to keep the original structure intact for reuse, while starting fresh in new projects.</li>
</ul>
<h4 id="benefits-of-a-template-repository"><strong>Benefits of a Template Repository:</strong><a aria-hidden="true" class="anchor-heading icon-link" href="#benefits-of-a-template-repository"></a></h4>
<ol>
<li><strong>Easy New Repositories:</strong>
<ul>
<li>Users (including you) can click the <strong>"Use this template"</strong> button on GitHub to create a new repository based on your template without including the git history.</li>
</ul>
</li>
<li><strong>Clean Starting Point:</strong>
<ul>
<li>New repositories are entirely independent of the template, preventing accidental references to the original fork.</li>
</ul>
</li>
<li><strong>Encourages Consistency:</strong>
<ul>
<li>Using the same template ensures that all new projects start with the same structure and setup.</li>
</ul>
</li>
</ol>
<h4 id="how-to-do-it"><strong>How to Do It:</strong><a aria-hidden="true" class="anchor-heading icon-link" href="#how-to-do-it"></a></h4>
<ol>
<li>Go to your repository’s <strong>Settings</strong>.</li>
<li>Scroll down to the <strong>Template Repository</strong> section and enable it.</li>
<li>Click <strong>Save</strong>.</li>
</ol>
<hr>
<h3 id="changing-the-default-branch-to-template-clean"><strong>Changing the Default Branch to <code>template-clean</code></strong><a aria-hidden="true" class="anchor-heading icon-link" href="#changing-the-default-branch-to-template-clean"></a></h3>
<p>Making <code>template-clean</code> the default branch is ideal if:</p>
<ul>
<li>You want to preserve the original upstream <code>main</code> branch for future merges or references.</li>
<li>Your <code>template-clean</code> branch contains the stripped-down version and is the branch you intend others to work from.</li>
<li>You want contributors to default to working on the cleaned-up version without confusion.</li>
</ul>
<h4 id="benefits-of-setting-template-clean-as-default"><strong>Benefits of Setting <code>template-clean</code> as Default:</strong><a aria-hidden="true" class="anchor-heading icon-link" href="#benefits-of-setting-template-clean-as-default"></a></h4>
<ol>
<li><strong>Clarifies the Focus of the Fork:</strong>
<ul>
<li>Contributors or users of the repository will see the template-clean version first when visiting the repository.</li>
</ul>
</li>
<li><strong>Preserves Upstream Compatibility:</strong>
<ul>
<li>Keeping <code>main</code> aligned with upstream allows easy merging of updates into <code>template-clean</code> as needed.</li>
</ul>
</li>
<li><strong>Easier Workflow:</strong>
<ul>
<li>Using <code>template-clean</code> as the primary branch avoids confusion when working on your customized content.</li>
</ul>
</li>
</ol>
<h4 id="how-to-do-it-1"><strong>How to Do It:</strong><a aria-hidden="true" class="anchor-heading icon-link" href="#how-to-do-it-1"></a></h4>
<ol>
<li>Push your <code>template-clean</code> branch if you haven’t already:
<pre class="language-bash"><code class="language-bash"><span class="token function">git</span> checkout -b template-clean
<span class="token function">git</span> push origin template-clean
</code></pre>
</li>
<li>Go to your repository’s <strong>Settings</strong>.</li>
<li>Under <strong>Branches</strong>, change the default branch to <code>template-clean</code>.</li>
</ol>
<hr>
<h3 id="which-option-to-choose"><strong>Which Option to Choose?</strong><a aria-hidden="true" class="anchor-heading icon-link" href="#which-option-to-choose"></a></h3>
<h4 id="use-both-if-possible"><strong>Use Both If Possible</strong><a aria-hidden="true" class="anchor-heading icon-link" href="#use-both-if-possible"></a></h4>
<p>The best solution might be to combine both approaches:</p>
<ol>
<li>Make the repository a <strong>template repository</strong> to facilitate creating new projects.</li>
<li>Set <code>template-clean</code> as the <strong>default branch</strong> to signal that it is the main branch to work from.</li>
</ol>
<p>This setup ensures:</p>
<ul>
<li>New repositories can be created directly from the template.</li>
<li>Existing work or contributions default to the cleaned-up version.</li>
</ul>
<hr>
<h3 id="what-about-main"><strong>What About <code>main</code>?</strong><a aria-hidden="true" class="anchor-heading icon-link" href="#what-about-main"></a></h3>
<p>If you’re using both approaches, you can:</p>
<ul>
<li>Keep <code>main</code> aligned with the upstream repository for easy updates.</li>
<li>Use <code>template-clean</code> for all modifications, ensuring separation between upstream syncs and your customizations.</li>
</ul>
<p>This allows maximum flexibility for maintaining the template and staying updated with upstream changes.</p>
<h2 id="when-creating-a-template-do-you-specify-a-branch">When creating a template, do you specify a branch?<a aria-hidden="true" class="anchor-heading icon-link" href="#when-creating-a-template-do-you-specify-a-branch"></a></h2>
<p>No, you cannot specify a particular branch when creating a <strong>template repository</strong> on GitHub. The repository's default branch automatically becomes the template used when someone creates a new repository from it.</p>
<h3 id="key-points">Key Points:<a aria-hidden="true" class="anchor-heading icon-link" href="#key-points"></a></h3>
<ol>
<li>
<p><strong>Default Branch is Used</strong>:</p>
<ul>
<li>The current default branch of the repository will be used as the base for new repositories created from the template.</li>
</ul>
</li>
<li>
<p><strong>To Use a Specific Branch as the Template</strong>:</p>
<ul>
<li>Set the branch you want (e.g., <code>template-clean</code>) as the <strong>default branch</strong>:
<ul>
<li>Go to <strong>Settings</strong> → <strong>Branches</strong> → Change <strong>Default Branch</strong> to <code>template-clean</code>.</li>
</ul>
</li>
<li>Once it's the default branch, GitHub will use it for the template.</li>
</ul>
</li>
<li>
<p><strong>Other Branches Won’t Be Included</strong>:</p>
<ul>
<li>Only the contents of the default branch are copied into new repositories created from the template. Any other branches in the repository are not included.</li>
</ul>
</li>
</ol>
<h3 id="steps-to-prepare-your-template-repository">Steps to Prepare Your Template Repository:<a aria-hidden="true" class="anchor-heading icon-link" href="#steps-to-prepare-your-template-repository"></a></h3>
<ol>
<li>Ensure the branch you want as the template (e.g., <code>template-clean</code>) contains all the necessary content.</li>
<li>Set <code>template-clean</code> as the default branch.</li>
<li>Mark the repository as a template:
<ul>
<li>Go to <strong>Settings</strong> → Enable <strong>Template Repository</strong> under the Template Repository section.</li>
</ul>
</li>
<li>Optional: Keep the <code>main</code> branch for upstream updates or other purposes if needed.</li>
</ol>
<h3 id="example-workflow">Example Workflow:<a aria-hidden="true" class="anchor-heading icon-link" href="#example-workflow"></a></h3>
<ul>
<li><strong>Default Branch</strong>: <code>template-clean</code></li>
<li><strong>Other Branch</strong>: <code>main</code> (sync with upstream or store unmodified content)</li>
<li>When someone creates a repository from your template, they will only see the content of the <code>template-clean</code> branch. </li>
</ul>
<p>This ensures the branch you intend for templating is the one users interact with.</p>
<h2 id="so-i-basically-have-to-make-the-template-branch-the-default">So I basically HAVE to make the template branch the default.<a aria-hidden="true" class="anchor-heading icon-link" href="#so-i-basically-have-to-make-the-template-branch-the-default"></a></h2>
<p>Yes, if you want a specific branch (e.g., <code>template-clean</code>) to be used as the template for new repositories, you <strong>have to make it the default branch</strong>. GitHub’s template repository feature always uses the <strong>default branch</strong> as the basis for creating new repositories. </p>
<h3 id="why-you-need-to-make-it-default">Why You Need to Make It Default:<a aria-hidden="true" class="anchor-heading icon-link" href="#why-you-need-to-make-it-default"></a></h3>
<ol>
<li><strong>GitHub Defaults to Default</strong>: 
<ul>
<li>The default branch is the one GitHub references for templates, so only its contents are copied when someone creates a repository from the template.</li>
</ul>
</li>
<li><strong>No Branch Selection for Templates</strong>:
<ul>
<li>There’s no way to specify a branch explicitly for the template functionality. GitHub assumes the default branch is the "master copy."</li>
</ul>
</li>
</ol>
<hr>
<h3 id="how-to-transition-to-a-template-branch-as-default">How to Transition to a Template Branch as Default:<a aria-hidden="true" class="anchor-heading icon-link" href="#how-to-transition-to-a-template-branch-as-default"></a></h3>
<ol>
<li>
<p><strong>Ensure Your Template Branch is Ready</strong>:</p>
<ul>
<li>Confirm <code>template-clean</code> contains all the content you want to serve as the starting point for new repositories.</li>
</ul>
</li>
<li>
<p><strong>Set the Template Branch as Default</strong>:</p>
<ul>
<li>Go to <strong>Settings</strong> → <strong>Branches</strong> → Set <code>template-clean</code> as the default branch.</li>
</ul>
</li>
<li>
<p><strong>Retain Other Branches for Maintenance</strong>:</p>
<ul>
<li>If you have other branches like <code>main</code> (e.g., for upstream sync), they remain intact and accessible but won’t be part of the template.</li>
</ul>
</li>
<li>
<p><strong>Test the Template</strong>:</p>
<ul>
<li>Use the <strong>"Use this template"</strong> button to create a test repository and verify that everything works as expected.</li>
</ul>
</li>
</ol>
<hr>
<h3 id="example-setup">Example Setup:<a aria-hidden="true" class="anchor-heading icon-link" href="#example-setup"></a></h3>
<ul>
<li><strong><code>template-clean</code></strong>: The stripped-down branch containing the template content. Set as the default branch.</li>
<li><strong><code>main</code></strong>: Tracks the upstream repository (optional) or keeps the original content for reference.</li>
<li><strong>Other Branches</strong>: Can exist for additional workflows, but they won’t impact the template functionality.</li>
</ul>
<p>By making the <code>template-clean</code> branch the default, you ensure that users (or you) creating new repositories from the template get exactly what you’ve prepared in that branch.</p>
<h2 id="how-do-i-change-the-default-branch-using-the-default-branch-setting-in-github-web-ui-seems-to-just-rename-it">how do I change the default branch? Using the "default branch" setting in github web ui seems to just rename it?<a aria-hidden="true" class="anchor-heading icon-link" href="#how-do-i-change-the-default-branch-using-the-default-branch-setting-in-github-web-ui-seems-to-just-rename-it"></a></h2>
<h2 id="csp-middleware-testing-with-reportingobserver-dave">CSP Middleware testing with ReportingObserver (dave)<a aria-hidden="true" class="anchor-heading icon-link" href="#csp-middleware-testing-with-reportingobserver-dave"></a></h2>
<p>what is the purpose of this code in the top-level index.js:</p>
<p>// For testing purpose of CSP middleware
const userAgentString = navigator.userAgent;
const chromeAgent = userAgentString.indexOf("Chrome") > -1;</p>
<p>if (chromeAgent) {
const observer = new ReportingObserver((reports) => {
for (const report of reports) {
console.log(report.type, report.url, report.body);
}
}, { buffered: true });</p>
<p>  observer.observe();
}</p>
<h2 id="csp-middleware-testing-with-reportingobserver-chatgpt">CSP Middleware testing with ReportingObserver (chatgpt)<a aria-hidden="true" class="anchor-heading icon-link" href="#csp-middleware-testing-with-reportingobserver-chatgpt"></a></h2>
<p>This code is designed to monitor and log reports related to <strong>Content Security Policy (CSP)</strong> violations in browsers that support the <strong>Reporting API</strong>, specifically for testing and debugging purposes. Here's a breakdown of its functionality:</p>
<hr>
<h3 id="what-it-does"><strong>What It Does</strong><a aria-hidden="true" class="anchor-heading icon-link" href="#what-it-does"></a></h3>
<ol>
<li>
<p><strong>Check if the Browser is Chrome</strong>:</p>
<ul>
<li>The <code>userAgentString</code> and <code>chromeAgent</code> check whether the browser is Chrome by inspecting the <code>navigator.userAgent</code>.</li>
<li>If the browser is not Chrome, the code does nothing because Chrome is the primary target for this debugging tool.</li>
</ul>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> userAgentString <span class="token operator">=</span> <span class="token dom variable">navigator</span><span class="token punctuation">.</span><span class="token property-access">userAgent</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> chromeAgent <span class="token operator">=</span> userAgentString<span class="token punctuation">.</span><span class="token method function property-access">indexOf</span><span class="token punctuation">(</span><span class="token string">"Chrome"</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
</code></pre>
</li>
<li>
<p><strong>Create a Reporting Observer</strong>:</p>
<ul>
<li>If the browser is Chrome, a <code>ReportingObserver</code> is instantiated. This API is used to listen for specific browser-generated reports, such as CSP violations or deprecation warnings.</li>
<li>The <code>ReportingObserver</code> constructor takes a callback and options:
<ul>
<li><strong>Callback</strong>: Handles the received reports.</li>
<li><strong>Options</strong>: Includes <code>{ buffered: true }</code>, meaning it also fetches buffered (previously collected) reports when the observer starts.</li>
</ul>
</li>
</ul>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> observer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReportingObserver</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">reports</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> report <span class="token keyword">of</span> reports<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>report<span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">,</span> report<span class="token punctuation">.</span><span class="token property-access">url</span><span class="token punctuation">,</span> report<span class="token punctuation">.</span><span class="token property-access">body</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">buffered</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</li>
<li>
<p><strong>Start Observing Reports</strong>:</p>
<ul>
<li><code>observer.observe()</code> starts the ReportingObserver to monitor relevant browser events.</li>
<li>It listens for reports of types such as:
<ul>
<li><strong>CSP violations</strong>: Reports when a script, style, or resource violates a Content Security Policy.</li>
<li><strong>Deprecation warnings</strong>: Reports for features that are deprecated or being removed.</li>
</ul>
</li>
<li>The <code>console.log</code> call outputs the report details, including:
<ul>
<li>The type of the report (e.g., <code>csp-violation</code> or <code>deprecation</code>).</li>
<li>The URL where the violation or issue occurred.</li>
<li>The report body, which contains detailed information about the event.</li>
</ul>
</li>
</ul>
<pre class="language-javascript"><code class="language-javascript">observer<span class="token punctuation">.</span><span class="token method function property-access">observe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</li>
</ol>
<hr>
<h3 id="purpose"><strong>Purpose</strong><a aria-hidden="true" class="anchor-heading icon-link" href="#purpose"></a></h3>
<ul>
<li><strong>Testing CSP Rules</strong>: 
<ul>
<li>Helps developers monitor if CSP rules are enforced correctly and identify potential issues during development or debugging.</li>
</ul>
</li>
<li><strong>Debugging Deprecations</strong>: 
<ul>
<li>Allows developers to catch deprecation warnings for features that may stop working in future browser versions.</li>
</ul>
</li>
<li><strong>Chrome-Specific Testing</strong>: 
<ul>
<li>Focuses on Chrome, which has good support for the Reporting API, making it a suitable choice for debugging CSP and deprecations.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="why-its-conditional-on-chrome"><strong>Why It's Conditional on Chrome</strong><a aria-hidden="true" class="anchor-heading icon-link" href="#why-its-conditional-on-chrome"></a></h3>
<p>The code is restricted to Chrome (<code>chromeAgent</code>) because:</p>
<ul>
<li>Not all browsers fully support the Reporting API.</li>
<li>Developers often need to target a specific browser for debugging due to differences in CSP handling or feature deprecations.</li>
</ul>
<p>If broader browser support is required, this condition could be removed, and feature detection for <code>ReportingObserver</code> could be used instead.</p>
<hr>
<h3 id="when-to-remove-this-code"><strong>When to Remove This Code</strong><a aria-hidden="true" class="anchor-heading icon-link" href="#when-to-remove-this-code"></a></h3>
<p>This is clearly testing/debugging code, so it should be removed or disabled in production:</p>
<ul>
<li><strong>Performance</strong>: Observers can add overhead by collecting and processing reports.</li>
<li><strong>Security</strong>: Logging sensitive CSP violation data in production could expose details to attackers if accessible.</li>
</ul>
<p>For production, consider:</p>
<ul>
<li>Disabling the observer entirely.</li>
<li>Replacing <code>console.log</code> with a mechanism to securely report issues to your server (if needed).</li>
</ul>
<hr>
<strong>Backlinks</strong>
<ul>
<li><a href="/wiki/notes/qbrgvu0x2z73pyq32usktni">Lumenous</a></li>
</ul>