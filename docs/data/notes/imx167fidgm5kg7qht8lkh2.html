<h1 id="kosmion-log">Kosmion Log<a aria-hidden="true" class="anchor-heading icon-link" href="#kosmion-log"></a></h1>
<h2 id="t2024080813">t.2024.08.08.13<a aria-hidden="true" class="anchor-heading icon-link" href="#t2024080813"></a></h2>
<ul>
<li>"micro-graph" approach, where each relator is its own named graph, might have some benefits
<ul>
<li>maybe you could preserve (some of) the classic S-P-O approach, layering on <a href="/wiki/notes/nd9jv0vxttzc1gadynsa7ks">@christopher-welty</a>'s Ontology for Fluents</li>
</ul>
</li>
</ul>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" checked disabled> regarding <a href="/wiki/notes/lo2gql2l1s4q9n27m52bao8">Ontogen</a>, is it at odds with keeping history (of events, relator validity) in the dataset? i.e., RDF immutability or event-driven/relator-based RDF 
<ul>
<li>see <a href="/wiki/notes/2a1a9keerfu720gvohem49e">Ontogen Vs Relator Based Rdf</a></li>
<li>graph-based versioning might be orthogonal to an immutable-ish data store (in text files, in git)</li>
</ul>
</li>
</ul>
<h1 id="t2024081712">t.2024.08.17.12<a aria-hidden="true" class="anchor-heading icon-link" href="#t2024081712"></a></h1>
<ul>
<li>everything that exists has some physical aspect, but some physical systems have sub-systems that support "aphysical (supra-physical) things", and it can be useful to speak of those as universes of their own and abstract away the "physical-prime" context (that is kinda boring because it subsumes everything else). Call them supra-universes or subcontexts, eg., a functioning brain, an operating computer, a networked game.</li>
<li>versioning everywhere... major signals breaking change, so there's value in using the major version with no minor specific as an alias to "latest minor"</li>
<li>there's value in aliasing your ontology to other used ontologies... avoids a profusion of namespacing. Maybe you don't like that other guy's uptime or prefix choices</li>
<li>how much of starting with a conventional ontology leak into <a href="/wiki/notes/xbpa7vv9hwari8435fttsw3">Relator</a>-based predication. </li>
<li>as long as the reference is unique, you can do nice aliasing that cuts through 
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled> could do aliasing in RDF... maybe just an import statement pointing to current version.</li>
</ul>
</li>
</ul>
<h2 id="t2024081713">t.2024.08.17.13<a aria-hidden="true" class="anchor-heading icon-link" href="#t2024081713"></a></h2>
<ul>
<li>holonic RDF, where each level of aggregation gets its own versioning
<ul>
<li>used-version</li>
<li>WHAT WAS that <a href="/wiki/notes/yh2klbhlafo49gizvkn35ai">Cool Uris</a> tech for appending stuff</li>
</ul>
</li>
</ul>
<h2 id="t2024101112">t.2024.10.11.12<a aria-hidden="true" class="anchor-heading icon-link" href="#t2024101112"></a></h2>
<ul>
<li>using <a href="/wiki/notes/c3cf5t7ybox6k56n992pnkr">gUFO</a> as a guide, my head is starting to swim.  </li>
</ul>
<h2 id="t2024101307">t.2024.10.13.07<a aria-hidden="true" class="anchor-heading icon-link" href="#t2024101307"></a></h2>
<ul>
<li><a href="/wiki/notes/yc40keh2zrpwnsyolhp1md1">PROV-O</a> has <code>qualifiedInfluence</code> and its subproperties:
<ul>
<li>prov:qualifiedAssociation</li>
<li>prov:qualifiedRevision</li>
<li>prov:qualifiedInvalidation</li>
<li>prov:qualifiedPrimarySource</li>
<li>prov:qualifiedDerivation</li>
<li>prov:qualifiedGeneration</li>
<li>prov:qualifiedUsage</li>
<li>prov:qualifiedQuotation</li>
<li>prov:qualifiedStart</li>
<li>prov:qualifiedAttribution</li>
<li>prov:qualifiedEnd</li>
<li>prov:qualifiedCommunication</li>
<li>prov:qualifiedDelegation</li>
</ul>
</li>
</ul>
<h2 id="t2024101511">t.2024.10.15.11<a aria-hidden="true" class="anchor-heading icon-link" href="#t2024101511"></a></h2>
<ul>
<li>RelatorCatalog per entity collects all the RelatorSets, which are datasets where the default graph (mutable) points to the immutable named graphs. 
<ul>
<li>pointer isn't strictly necessary, but might speed querying, aid distribution-packing, or be used for consistency checking</li>
</ul>
</li>
<li>damn, brain not working, why did we need a catalog of relatorsets?
<ul>
<li>well, all the info about an entity might be split across different datasets. </li>
<li>the fact that there's not an inverse property for dcat:dataset might be a hint, but it seems like data should be allowed to join itself? </li>
</ul>
</li>
<li>Another reason for separating names from downloadURLs, you might want to shadow-recreate something on your own (or with local files)</li>
</ul>
<h2 id="t2024101512">t.2024.10.15.12<a aria-hidden="true" class="anchor-heading icon-link" href="#t2024101512"></a></h2>
<ul>
<li>using IRI refs instead of anyURI helps clear the clutter, but maybe there'd be cases where you want to preserve a sourceURL and change the prefix</li>
<li>things aren't literally immutable in github, but quasi-immutability (aka stable) is better... allows you to preserve history but take out PI, typos, and embarassments.</li>
<li>for concision, maybe the "current relator" gets duplicated into the placeholder/primary entity?</li>
<li>it makes sense to be able to come at things from both ways, with atoms making claims on collectives/entities. named graphs as atoms probably makes the most sense.</li>
<li>atomicity is a facit.
<ul>
<li>datatype-property-carrying</li>
</ul>
</li>
<li>conventional RDF, esp. class hierarchy, only for interfacing with RDF and owl: only for owl.</li>
<li>ethos is: it's just guidelines. so lots of things should be in the </li>
</ul>
<h2 id="t2024101516">t.2024.10.15.16<a aria-hidden="true" class="anchor-heading icon-link" href="#t2024101516"></a></h2>
<ul>
<li><a href="http://www.w3.org/ns/prov#Agent">http://www.w3.org/ns/prov#Agent</a> should be a sublass of Entity? Or mayb eit doesn't matter. </li>
<li>probably I just just go for it, make kosm: the one stop shop for fixing everyone else's issues and integrating it. A ruthless and misleading-ish approach would be to steal the most popular terms.
<ul>
<li>review 'em for
<ul>
<li>domain and range are reasonable</li>
<li>document is literal, sense is IRI.
<ul>
<li>could use a new datatype for IRI that includes folder hierarchy pattern matching, I guess I can leave that to the computers to develop. we're just at v0 buddy.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>is the time to modularize: right from the start?</li>
<li>full, core, facet-stereotypes, borrowed terms/mnemonic forks.</li>
<li>can you make a property's subproperty require different things
<ul>
<li>e.g downloadURL, homepageURL, et al subproperty downloadIRI. ie.., a superproperty for objectprop/dataprop</li>
</ul>
</li>
<li>it's going to be so great, you'll want to use quasi-immutable, facet-oriented RDF for your ontologies too.</li>
<li>make two versions avail, one with owl:includes, or rather kosm:includes means the same thing </li>
<li>everything is a data catalog, or rather, every decent (kosmethodology-compliant entity) is</li>
<li></li>
</ul>